## はじめに

FE においてレンダー、レンダリングという言葉はさまざまな場面で登場しますよね。
自分はなんとなく描写する、画面上に表示するというイメージでレンダーと口にしていたのですが、例えば SSR におけるレンダリングって表示していると言えるのでしょうか

## ブラウザにおけるレンダリング(The Pixel Pipeline)

### A. HTML(あるいは DOM)を画面に描写すること

レンダリングエンジンの処理工程は、The Pixel Pipeline と呼ばれ、詳しくは以下の記事が参考になります。(コンテンツが動的に更新されるということがウェブの特徴であり、そのためいくつかの中間表現を持っています)

https://web.dev/articles/rendering-performance

レンダリングエンジンは最終的に OS のグラフィックライブラリに描画したものを渡すことになるので、レンダリングエンジンというレイヤーが行なっているレンダーの役割は、**グラフィックライブラリに描画したものを渡すこと** と言えるかもしれません。
しかし、多くの文脈において、レンダリングエンジン以降のレイヤーでモニターに表示されるまでの処理を深く気にする必要はないので、ブラウザレンダリングとは、単純に HTML、DOM を画面に描写すること と捉えても差し支えないと思われます。(後述する React においては、ブラウザレンダリングは混乱を避けるために このことは Paint と呼ばれています。)

## React におけるレンダー

### A. React がコンポーネントを呼び出すこと

これは React の公式ドキュメントにも以下のように明記されています。なお、コンポーネントを呼び出すことを実行すること、と解釈しても大きな齟齬はないと思われます。(英語ではレンダーではなく Rendering となっています。)

> レンダーとは React がコンポーネントを呼び出すことです
> “Rendering” is React calling your components.

https://ja.react.dev/learn/render-and-commit

https://react.dev/learn/render-and-commit

そして、React では以下のような 4 つのフェーズに分けて、インタラクティブな要素が画面に再描画されます。

- **トリガー**
  - Set 関数など、レンダーをトリガーする。
- **レンダーフェーズ**
  - レンダー(コンポーネントの呼び出し)が行われる
- **コミットフェーズ**
  - レンダー間で差があった場合のみ DOM ノード を変更する
- **ペイント(ブラウザレンダリング)**
  - ブラウザが画面を再描画する。(React の責務ではない)

つまり、React ではレンダー(コンポーネントに呼び出し)がされたとしても、ReactTree(仮想 DOM)上で差分がなければ DOM が更新されず、画面には反映されないということになります。

## レンダリングパターンとしてのレンダリング(CSR/SSR/SSG)

**_前書き_**
CSR(Client-side-rendering)、SSR(Server-side-rendering)、SSG(Static-site-generator/Pre-Rendering)などと言った用語はレンダリングパターンの用語として利用されます。
これらの用語はそれぞれ概念を表す言葉なので、SSR の R の部分の意味について切り出して考えるのも少々的を射ていない話かもしれませんが、概ねページ(コンテンツ)の生成の仕方が焦点にあたってきた経緯があります。
レンダリングの意味を考えると、**ページのコンテンツの生成(要素を生成して DOM に追加、更新すること)、あるいは HTML ファイルそのものの生成** を指していると捉えることができそうです。特に、事前レンダリング(SSR/SSG)の意味ではもっぱら、**クライアントサイドで実行されるコードをサーバーサイドで実行する**という意味合いが含まれてきます。

(※他の文脈では、isomorphic なコンポーネントがサーバー側で実行されることを SSR、クライアント側で実行されることを CSR などとライトに使われることもあります。)

## CSR

**ページの描写時に、クライアントサイドで javaScript によってコンテンツを生成し DOM を更新すること**を指します。
この言葉は初期表示でも画面回遊時(ナビゲーション時)でも使われます。
CSR というモデルが出る以前は、コンテンツを含む HTML と、ページをインタラクティブにするために JQuery などのファイルを別々に作成するのが主流でした。ページ遷移の際も、遷移先のページの HTML ファイルが送られてくることになります。
一方で、 ナビゲーションが CSR である場合は、HTML ファイルではなく js や json のデータがサーバーから送られ、クライアントサイドでスクリプトが実行されコンテンツが生成されます。初期表示が CSR である場合はコンテンツが空の HTML が送られてきたのちに、ナビゲーションと同様の流れでスクリプトが読み込まれ、コンテンツ用のデータを fetch してくるような流れで描写されます。

ただし、この頃の SPA とも呼ばれるような空の HTML を返すアプリケーションでは、SEO 対策が困難であるという欠点がありました。(他にもパフォーマンス面やデータ転送面などの欠点もあります。)

> この頃の従来の MVC のようなモデルなどをレトロニム的に SSR と呼ぶこともあったようです。

## 事前レンダリング(SSR/SSG)

### ① クライアントサイドでも動作するコードをサーバーサイドで実行して ②HTML ファイルを(サーバーサイドで)生成すること

SSR と SSG という用語は事前レンダリングという言葉の括り方をされます。(事前という言葉の対象はレスポンスが送信されるタイミングであると解釈できます。)

> 事前のタイミング
> SSG: build 時
> SSR: リクエスト時(訪問時)

このレンダリングパターンの利点として、 CSR のみのアプリケーション(CRA など) と比較して、初期表示やハードナビゲーションのような場面でもコンテンツを含む HTML ファイルを事前に生成しておくこと があげられます。

### SSR であるもの、ないもの

SSR が事前に HTML ファイルを生成するモデルと定義するなら、SpringBoot や Rails などのサーバーサイドテンプレートをはじめ、SPA 以前のモデル全ても SSR であると捉えることもできそうですが、あまりこう言ったモデルに対しては SSR という言葉は使われません。(CSR が出てきた当初レトロニム的にサーバー側でコンテンツを生成していたモデルを SSR と使われたりしていたことはあったみたいです。)
現在の主流の SSR フレームワーク登場の経緯として、React や Vue のようなクライアントサイドで動いていたコードをサーバーサイドで実行(レンダー)して HTML を事前に生成するという意味合いがあったためです。
(サーバーサイドで HTML を生成するものを SSR というなら、昨今の SSR は SSR wiht Hydration に相当すると考えられますが、ここの定義なら結果的に SSR は Hydration という概念がセットになっていると言っても過言ではないと思われます。)

また、RSC の SC(サーバーコンポーネント)は SSR であるかということについては React 公式も、RSC と SSR は両立する別の概念であるとしています。
確かに SC はサーバーサイドでのみレンダーされるものですが、SSR は、CC(クライアントコンポーネント)や SharedComponent を含めてサーバーサイドで実行して HTML を生成することだからです。

> **Does this replace SSR?**
> No, they’re complementary. SSR is primarily a technique to quickly display a non-interactive version of client components.

https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#does-this-replace-ssr

### SSR の誕生

SSR フレームワークの初出と考えられそうな候補として Backbone.js の Rendr があります。Backbone.js は最古の SPA フレームワークで、クライアントサイドテンプレートが採用されています。

当初の CSR のアプリケーションは、SEO 対策のために、別言語(Ruby など)で二重開発をして初回アクセス時にはサーバーサイドで HTML ファイルを生成したり、ヘッドレスブラウザのようなものを挟み、そこで js を実行して HTML を生成するなどの対応をしていたようです。

ダイナミックレンダリング
https://developers.google.com/search/docs/crawling-indexing/javascript/dynamic-rendering?hl=ja

js を実行して HTML を生成してくれるサービス
https://prerender.io/

そこで Rendr が取ったアプローチが、nodejs を採用し、Ruby との二重開発で共通していたロジックは Isomolphic(サーバーサイド/クライアントサイドどちらでも実行できる)なコードとすることでした。
なお、Rendr の作者の Rendr の公開スライドに、すでに hydrate という言葉が出ていることから、クライアントサイドで要素をインタラクティブにするフェーズを hydrate という文化はこの時にはすでに存在していたようです。

https://medium.com/airbnb-engineering/our-first-node-js-app-backbone-on-the-client-and-server-c659abb0e2b4

https://www.slideshare.net/slideshow/introducing-rendr-run-your-backbonejs-apps-on-the-client-and-server/19106546
